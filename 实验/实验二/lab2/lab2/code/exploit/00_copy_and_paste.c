#ifndef __MYIOCTL_H__
#define __MYIOCTL_H__

#include <linux/ioctl.h>
#include <linux/types.h>

struct file_msg{
	unsigned long pbuf;
	size_t count;
	loff_t pos;
	unsigned int flag;
};

#define EXT4_IOC_PWRITE_NEW _IOW('f',36,struct file_msg)

#endif

****************************
	unsigned int flag;
	unsigned int dst_lblk;


***************************

/*add */
	case EXT4_IOC_PWRITE_NEW:
	{
		int ret;
		const unsigned blkbits = inode->i_blkbits;
		struct file_msg mymsg;
		memset(&mymsg,0,sizeof(struct file_msg));

		if(copy_from_user(&mymsg,(struct file_msg __user *)arg,sizeof(mymsg)))
			return -EFAULT;

		if(mymsg.pos < 0 || mymsg.count < 0)
			return -EINVAL;

		inode->flag=mymsg.flag;
		inode->dst_lblk=mymsg.pos >> blkbits;

		printk(KERN_INFO "MYTEST user->FS: flag = %u, dst_lblk = %u\n",inode->flag,inode->dst_lblk);

		ret=-ESPIPE;
		if(filp->f_mode & FMODE_PWRITE)
			ret=vfs_write(filp,(char __user *)mymsg.pbuf,mymsg.count,&(mymsg.pos));

		inode->flag=0;
		inode->dst_lblk=0;

		return ret;
	}

********************************


		bh->flag=0;
		
		if(inode->flag>0&&inode->dst_lblk==block){
			printk(KERN_INFO "MYTEST FS->buffer_head: flag = %u, dst_lblk = %u\n",inode->flag,inode->dst_lblk);	
			
			bh->flag=inode->flag;
			inode->flag=0;
			inode->dst_lblk=0;
		}

******************************

	if(bh->flag > 0)
	{
		printk(KERN_INFO "MYTEST buffer_head->bio_vec: flag = %u\n",bh->flag);
		
		io->io_bio->bi_io_vec[io->io_bio->bi_vcnt - 1].flag = bh->flag;
		
		bh->flag=0;
	}
	else{
		io->io_bio->bi_io_vec[io->io_bio->bi_vcnt-1].flag=0;
	}
	


*******************************


static int noop_dispatch(struct request_queue *q, int force)
{
	struct noop_data *nd = q->elevator->elevator_data;
	struct request *rq;

	rq = list_first_entry_or_null(&nd->queue, struct request, queuelist);
	if (rq&&rq->bio) {
		int i;
		struct bio_vec *bvec;
		struct bio *bio1=rq->bio;

		while(bio1!=NULL){
			if(bio1->bi_io_vec&&bio1->bi_io_vec->bv_page&&bio1->bi_vcnt>0){
				bio_for_each_segment_all(bvec,bio1,i){
					if(bvec->flag>0){
						printk(KERN_INFO "MYTEST noop: flag = %u\n",bvec->flag);
					}
				}
			}

			if(bio1==rq->biotail)
				break;

			bio1=bio1->bi_next;
		}
		

		list_del_init(&rq->queuelist);
		elv_dispatch_sort(q, rq);
		return 1;
	}
	return 0;
}



************************************
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "/usr/src/linux-4.15/include/linux/myioctl.h"
int main(){
	int fd,ret,i;
	char ch[4096];
	struct file_msg mymsg;
	memset(&mymsg,0, sizsof(struct file_msg));
	memset(ch , '1', sizeof(ch)) ;

	fd = open("/home/wjt/Desktop/test.txt", O_RDWR);
	if(fd<0)
	{
		perror("open" );
		exit( -1);
	}

	for(i = ; i < 3; i++){
		mymsg.pbuf = (unsigned long)ch;
		mymsg.count =4096;
		mymsg.pos = 4096 *i;
		mymsg.flag = i+1;

		printf( "pos = %lu,count = %lu,flag = %u\n" ,mymsg.pos,mymsg.count,mymsg.flag);
		if((ret = ioctl(fd,EXT4_IOC_MYTEST,(unsigned long)(&mymsg))) < 0)
		{
			printf( "ret = %d, ioctl pwrite test failed\n", ret);
			exit(-1);
		}
	}
	
	fsync(fd);
	close(fd);

	return 0;
}